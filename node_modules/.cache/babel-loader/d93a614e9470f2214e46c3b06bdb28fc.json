{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n/** @typedef {import(\"../Module\")} Module */\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\ANIKE\\\\Desktop\\\\Udemy\\\\Web Developing\\\\keeper-app-part-1-starting\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\ANIKE\\\\Desktop\\\\Udemy\\\\Web Developing\\\\keeper-app-part-1-starting\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\ANIKE\\\\Desktop\\\\Udemy\\\\Web Developing\\\\keeper-app-part-1-starting\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar DependencyReference = /*#__PURE__*/function () {\n  // TODO webpack 5: module must be dynamic, you must pass a function returning a module\n  // This is needed to remove the hack in ConcatenatedModule\n  // The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n\n  /**\n   *\n   * @param {Module} module the referenced module\n   * @param {string[] | boolean} importedNames imported named from the module\n   * @param {boolean=} weak if this is a weak reference\n   * @param {number} order the order information or NaN if don't care\n   */\n  function DependencyReference(module, importedNames) {\n    var weak = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;\n\n    _classCallCheck(this, DependencyReference);\n\n    // TODO webpack 5: make it a getter\n    this.module = module; // true: full object\n    // false: only sideeffects/no export\n    // array of strings: the exports with this names\n\n    this.importedNames = importedNames;\n    this.weak = !!weak;\n    this.order = order;\n  }\n  /**\n   * @param {DependencyReference[]} array an array (will be modified)\n   * @returns {DependencyReference[]} the array again\n   */\n\n\n  _createClass(DependencyReference, null, [{\n    key: \"sort\",\n    value: function sort(array) {\n      /** @type {WeakMap<DependencyReference, number>} */\n      var originalOrder = new WeakMap();\n      var i = 0;\n\n      var _iterator = _createForOfIteratorHelper(array),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ref = _step.value;\n          originalOrder.set(ref, i++);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return array.sort(function (a, b) {\n        var aOrder = a.order;\n        var bOrder = b.order;\n\n        if (isNaN(aOrder)) {\n          if (!isNaN(bOrder)) {\n            return 1;\n          }\n        } else {\n          if (isNaN(bOrder)) {\n            return -1;\n          }\n\n          if (aOrder !== bOrder) {\n            return aOrder - bOrder;\n          }\n        }\n\n        var aOrg = originalOrder.get(a);\n        var bOrg = originalOrder.get(b);\n        return aOrg - bOrg;\n      });\n    }\n  }]);\n\n  return DependencyReference;\n}();\n\nmodule.exports = DependencyReference;","map":null,"metadata":{},"sourceType":"script"}